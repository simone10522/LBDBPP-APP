"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/ObjectUtil.ts
var ObjectUtil_exports = {};
__export(ObjectUtil_exports, {
  cloneObject: () => cloneObject,
  default: () => ObjectUtil_default,
  isObject: () => isObject,
  mustBeObject: () => mustBeObject,
  objectClean: () => objectClean,
  objectClone: () => objectClone,
  objectEqual: () => objectEqual,
  objectFind: () => objectFind,
  objectGet: () => objectGet,
  objectKeys: () => objectKeys,
  objectLoop: () => objectLoop,
  objectMap: () => objectMap,
  objectOmit: () => objectOmit,
  objectRemap: () => objectRemap,
  objectSet: () => objectSet,
  objectSize: () => objectSize,
  objectSort: () => objectSort,
  objectToArray: () => objectToArray,
  objectValues: () => objectValues
});
module.exports = __toCommonJS(ObjectUtil_exports);
function objectMap(obj, fn) {
  mustBeObject(obj);
  const list = [];
  objectLoop(obj, (item, key, index) => {
    list.push(fn(item, key, index));
  });
  return list;
}
function objectRemap(obj, fn, options) {
  mustBeObject(obj);
  const clone = {};
  objectLoop(obj, (item, oldKey, index) => {
    const { key, value } = fn(item, oldKey, index);
    if ((options == null ? void 0 : options.strict) && key in clone) {
      throw new Error("objectRemap strict mode active, you can't remap the same key twice");
    }
    clone[key] = value;
  });
  return clone;
}
function objectLoop(obj, fn) {
  mustBeObject(obj);
  const keys = objectKeys(obj);
  for (let index = 0; index < keys.length; index++) {
    const key = keys[index];
    const stop = fn(obj[key], key, index);
    if (stop === false) {
      return false;
    }
  }
  return true;
}
function objectValues(obj) {
  mustBeObject(obj);
  return Object.values(obj);
}
function objectToArray(obj) {
  mustBeObject(obj);
  return objectValues(obj);
}
function objectKeys(obj) {
  mustBeObject(obj);
  if (Array.isArray(obj)) {
    return Array.from(obj.keys());
  }
  return Object.keys(obj);
}
function objectSize(obj) {
  return objectKeys(obj).length;
}
function objectSort(obj, fn) {
  mustBeObject(obj);
  const ordered = {};
  let sortedKeys = [];
  if (Array.isArray(fn)) {
    sortedKeys = fn.concat(objectKeys(obj).filter((key) => !fn.includes(key)));
  } else {
    sortedKeys = objectKeys(obj).sort(fn);
  }
  for (const key of sortedKeys) {
    ordered[key] = obj[key];
  }
  return ordered;
}
function cloneObject(obj) {
  return objectClone(obj);
}
function objectClone(obj, options) {
  mustBeObject(obj);
  if (Array.isArray(obj)) {
    const arr = [];
    for (const item of obj) {
      arr.push(
        isObject(item) ? objectClone(item) : item
      );
    }
    return arr;
  }
  const clone = {};
  objectLoop(obj, (value, key) => {
    if (typeof value === "object" && value != null && (typeof (options == null ? void 0 : options.deep) === "undefined" || options.deep)) {
      clone[key] = objectClone(value);
      return;
    }
    clone[key] = value;
  });
  return clone;
}
function objectSet(obj, path, value) {
  mustBeObject(obj);
  let pointer = obj;
  for (let index = 0; index < path.length; index++) {
    const key = path[index];
    const nextIndex = index + 1;
    if (!Object.prototype.hasOwnProperty.call(pointer, key) && nextIndex < path.length) {
      const key1 = path[nextIndex];
      if (typeof key1 === "number") {
        pointer[key] = [];
      } else {
        pointer[key] = {};
      }
    }
    if (nextIndex === path.length) {
      pointer[key] = value;
      if (value === void 0) {
        delete pointer[key];
      }
      break;
    }
    pointer = pointer[key];
  }
}
function objectEqual(first, second) {
  mustBeObject(first);
  mustBeObject(second);
  if (objectSize(first) !== objectSize(second)) {
    return false;
  }
  const res = objectLoop(first, (item, key) => {
    if (!(key in second) && key in first) {
      return false;
    }
    const item2 = second[key];
    if (item === null && item2 === null) {
      return true;
    }
    if (typeof item === "object" && typeof item2 === "object") {
      return objectEqual(item, item2);
    }
    return item === item2;
  });
  return res;
}
function objectClean(obj, options) {
  mustBeObject(obj);
  objectLoop(obj, (item, key) => {
    if ((typeof (options == null ? void 0 : options.cleanUndefined) === "undefined" || options.cleanUndefined) && item === void 0) {
      delete obj[key];
    } else if ((options == null ? void 0 : options.cleanFalsy) && !obj[key]) {
      delete obj[key];
    } else if ((options == null ? void 0 : options.cleanNull) && item === null) {
      delete obj[key];
    }
    if ((typeof (options == null ? void 0 : options.deep) === "undefined" || options.deep) && isObject(item)) {
      objectClean(item, options);
    }
  });
}
function objectOmit(obj, ...keys) {
  const cloned = objectClone(obj, { deep: false });
  for (const key of keys) {
    if (key in cloned) {
      delete cloned[key];
    }
  }
  return cloned;
}
function objectFind(obj, fn) {
  mustBeObject(obj);
  let res = void 0;
  objectLoop(obj, (value, key, index) => {
    const tmp = fn(value, key, index);
    if (tmp) {
      res = {
        key,
        value,
        index
      };
    }
    return !tmp;
  });
  return res;
}
function objectGet(obj, path) {
  if (!path || path === "" || Array.isArray(path) && path.length === 0) {
    return obj;
  }
  mustBeObject(obj);
  if (typeof path === "string") {
    path = path.split(".").map((it) => /^\d+$/g.test(it) ? Number.parseInt(it) : it);
  }
  let pointer = obj;
  for (let index = 0; index < path.length; index++) {
    const key = path[index];
    const nextIndex = index + 1;
    if (typeof key === "undefined" || !Object.prototype.hasOwnProperty.call(pointer, key) && nextIndex < path.length) {
      return void 0;
    }
    if (nextIndex === path.length) {
      return pointer[key];
    }
    pointer = pointer[key];
  }
  throw new Error(`it should never get there ! (${JSON.stringify(obj)}, ${path}, ${JSON.stringify(pointer)})`);
}
function isObject(item) {
  return typeof item === "object" && item !== null;
}
function mustBeObject(item) {
  if (!isObject(item)) {
    throw new Error("Input is not an object!");
  }
  return true;
}
var ObjectUtil_default = {
  objectClean,
  objectClone,
  objectEqual,
  objectFind,
  objectGet,
  objectKeys,
  objectLoop,
  objectMap,
  objectOmit,
  objectRemap,
  objectSet,
  objectSize,
  objectSort,
  // helpers
  isObject,
  mustBeObject,
  // deprecated
  objectToArray,
  cloneObject
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  cloneObject,
  isObject,
  mustBeObject,
  objectClean,
  objectClone,
  objectEqual,
  objectFind,
  objectGet,
  objectKeys,
  objectLoop,
  objectMap,
  objectOmit,
  objectRemap,
  objectSet,
  objectSize,
  objectSort,
  objectToArray,
  objectValues
});
