type BasicObjectKeys = string | number | symbol;
type BasicObject<K extends BasicObjectKeys = BasicObjectKeys, V = any> = {
    [P in K]?: V;
};
/**
 * Remap an object to an array through a function
 *
 * (Same as Array.map but for objects)
 *
 * @param obj the object to remap
 * @param fn the function to run for each key: value pairs
 * @returns {Array} a new array filled with the object fn callback
 */
declare function objectMap<T = any, J = any, K extends BasicObjectKeys = BasicObjectKeys>(obj: BasicObject<K, T>, fn: (value: T, key: K, index: number) => J): Array<J>;
/**
 * a more advanced map function that transform an object back into another object
 *
 * note: if multiple key are the same only the last value will be set unless options.strict is enabled
 *
 * note2: for an array you will have to add manual typing to the `key` like this: `key: number`
 *
 * warn: the value is not a clone
 *
 * @param obj the object to remap (it will not be changed)
 * @param fn the function to run through
 * @param options optionnal options that change how the function works
 * @param options.strict (default: false) enabling this will throw an error if the same key is set twice
 * @returns a not deeply cloned object with it's key/values set from the [fn] function
 */
declare function objectRemap<T = any, J extends BasicObject = BasicObject, K extends BasicObjectKeys = BasicObjectKeys>(obj: BasicObject<K, T>, fn: (value: T, key: K, index: number) => {
    key: keyof J;
    value: J[typeof key];
}, options?: {
    strict?: boolean;
}): J;
/**
 * Loop through the object
 *
 * @param obj the object to loop through
 * @param fn the function to run for each childs if the function return `false` it will stop
 * @returns {boolean} return if the loop finished or ended early
 */
declare function objectLoop<T = any, K extends BasicObjectKeys = BasicObjectKeys>(obj: BasicObject<K, T>, fn: (value: T, key: K, index: number) => boolean | void): boolean;
/**
 * Transform an object to an array of its values
 *
 * @param obj the object to transform
 * @returns {Array} an array containing the object's values
 */
declare function objectValues<T = any>(obj: BasicObject<BasicObjectKeys, T>): Array<T>;
/**
 * @deprecated use `objectValues`
 */
declare function objectToArray<T = any>(obj: BasicObject<BasicObjectKeys, T>): Array<T>;
/**
 * return the keys of the object
 *
 * @param obj the object
 * @returns {Array} an array containing the object's keys
 */
declare function objectKeys<K extends BasicObjectKeys = BasicObjectKeys>(obj: BasicObject<K>): Array<K>;
/**
 * return the length of an object
 *
 * @param obj the object
 * @returns {number} the object's size
 */
declare function objectSize(obj: BasicObject): number;
/**
 * Sort an object by its keys
 *
 * Same as Array.sort but for objects
 *
 * @param obj the object to sort
 * @param fn (Optionnal) the function to run to sort
 * @returns a new object with the keys sorted using the fn
 */
declare function objectSort<T extends BasicObject>(obj: T, fn?: Array<keyof T> | ((a: keyof T, b: keyof T) => number)): T;
/**
 * @deprecated use `objectClone`
 */
declare function cloneObject<T extends BasicObject>(obj: T): T;
/**
 * Deeply clone an object
 *
 * @param obj the object to clone
 * @param options Cloning options
 * @param options.deep (Default: true) deeply clone the object
 * @returns the clone of the object
 */
declare function objectClone<T extends BasicObject>(obj: T, options?: {
    deep?: boolean;
}): T;
/**
 * deeply set the value at the path given
 *
 * (Create sub object/array if not made depending on path type (number = Array, string = Object))
 *
 * _NOTE: it is way quicker to use `obj[path][path]... = value` when possible_
 *
 * @param obj the object to set the value
 * @param path the path
 * @param value the value
 */
declare function objectSet(obj: BasicObject, path: Array<BasicObjectKeys>, value: any): void;
/**
 * deeply compare objects and return if they are equal or not
 *
 * @param first the first object
 * @param second the second object
 * @returns {boolean} a boolean representing the equality of the two objects
 */
declare function objectEqual(first: BasicObject, second: BasicObject): boolean;
/**
 * Deeply clean an object from having `undefined`,`null` and/or flasy values (options to enable)
 *
 * @param obj the object to clean
 * @param options cleanup options
 * @param {boolean?} options.cleanUndefined (default: true) clean undefined from the object
 * @param {boolean?} options.cleanFalsy (default: false) clean falsy values (including undefined and null) from the object see https://developer.mozilla.org/en-US/docs/Glossary/Falsy
 * @param {boolean?} options.cleanNull (default: false) clean null from the object
 * @param {boolean?} options.deep (default: true) deeply clean the object
 */
declare function objectClean(obj: BasicObject, options?: {
    cleanUndefined?: boolean;
    cleanNull?: boolean;
    cleanFalsy?: boolean;
    deep?: boolean;
}): void;
/**
 * return a new object containing only not the keys defined
 *
 * note: clone is not deep
 *
 * @param obj the object to clone
 * @param keys the keys to emit
 * @returns the cloned object
 */
declare function objectOmit<T extends BasicObject>(obj: T, ...keys: Array<string | number>): T;
/**
 * find an element in an object
 *
 * @param obj the object to find within
 * @param fn the function that find the object
 * @returns the key, value, index of the element found or undefined
 */
declare function objectFind<T = any, K extends BasicObjectKeys = BasicObjectKeys>(obj: BasicObject<K, T>, fn: (value: T, key: K, index: number) => boolean): {
    key: K;
    value: T;
} | undefined;
/**
 * go through an object to get a specific value
 *
 * note: it will be slower than getting it directly (ex: `obj['pouet']`)
 *
 * @param obj the object to go through
 * @param {Array<string | number | symbol> | string} path the path to follow (if path is a string it will be splitted with `.` and ints will be parsed)
 *
 * @returns the value if found or undefined if it was not found
 */
declare function objectGet<T = any>(obj: any, path: Array<string | number | symbol> | string): T | undefined;
/**
 * return if an item is an object
 *
 * @param item the item to check
 * @returns {boolean} the item is an object
 */
declare function isObject(item: any): item is BasicObject;
/**
 * Strict check for an object
 *
 * throw an error is the item is not an item
 *
 * @param item the item to check
 * @returns {boolean} true is the item is an object, else throw an error
 */
declare function mustBeObject(item: any): item is BasicObject;
declare const _default: {
    objectClean: typeof objectClean;
    objectClone: typeof objectClone;
    objectEqual: typeof objectEqual;
    objectFind: typeof objectFind;
    objectGet: typeof objectGet;
    objectKeys: typeof objectKeys;
    objectLoop: typeof objectLoop;
    objectMap: typeof objectMap;
    objectOmit: typeof objectOmit;
    objectRemap: typeof objectRemap;
    objectSet: typeof objectSet;
    objectSize: typeof objectSize;
    objectSort: typeof objectSort;
    isObject: typeof isObject;
    mustBeObject: typeof mustBeObject;
    objectToArray: typeof objectToArray;
    cloneObject: typeof cloneObject;
};

export { type BasicObject, type BasicObjectKeys, cloneObject, _default as default, isObject, mustBeObject, objectClean, objectClone, objectEqual, objectFind, objectGet, objectKeys, objectLoop, objectMap, objectOmit, objectRemap, objectSet, objectSize, objectSort, objectToArray, objectValues };
