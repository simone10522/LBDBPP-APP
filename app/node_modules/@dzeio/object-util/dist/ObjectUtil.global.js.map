{"version":3,"sources":["../src/ObjectUtil.ts"],"sourcesContent":["export type BasicObjectKeys = string | number | symbol\nexport type BasicObject<K extends BasicObjectKeys = BasicObjectKeys, V = any> = { [P in K]?: V }\n\n/**\n * Remap an object to an array through a function\n *\n * (Same as Array.map but for objects)\n *\n * @param obj the object to remap\n * @param fn the function to run for each key: value pairs\n * @returns {Array} a new array filled with the object fn callback\n */\nexport function objectMap<T = any, J = any, K extends BasicObjectKeys = BasicObjectKeys>(\n\tobj: BasicObject<K, T>,\n\tfn: (value: T, key: K, index: number) => J\n): Array<J> {\n\tmustBeObject(obj)\n\tconst list: Array<J> = []\n\tobjectLoop(obj, (item, key, index) => {\n\t\tlist.push(fn(item, key, index))\n\t})\n\treturn list\n}\n\n/**\n * a more advanced map function that transform an object back into another object\n *\n * note: if multiple key are the same only the last value will be set unless options.strict is enabled\n *\n * note2: for an array you will have to add manual typing to the `key` like this: `key: number`\n *\n * warn: the value is not a clone\n *\n * @param obj the object to remap (it will not be changed)\n * @param fn the function to run through\n * @param options optionnal options that change how the function works\n * @param options.strict (default: false) enabling this will throw an error if the same key is set twice\n * @returns a not deeply cloned object with it's key/values set from the [fn] function\n */\nexport function objectRemap<T = any, J extends BasicObject = BasicObject, K extends BasicObjectKeys = BasicObjectKeys>(\n\tobj: BasicObject<K, T>,\n\tfn: (value: T, key: K, index: number) => {key: keyof J, value: J[typeof key]},\n\toptions?: { strict?: boolean }\n): J {\n\tmustBeObject(obj)\n\n\t// create a clone\n\tconst clone: J = {} as any\n\n\t// loop through each keys\n\tobjectLoop(obj, (item, oldKey, index) => {\n\t\tconst { key, value } = fn(item, oldKey, index)\n\t\tif (options?.strict && key in clone) {\n\t\t\tthrow new Error('objectRemap strict mode active, you can\\'t remap the same key twice')\n\t\t}\n\n\t\t// set new key pair into the clone\n\t\tclone[key] = value\n\t})\n\treturn clone\n}\n\n/**\n * Loop through the object\n *\n * @param obj the object to loop through\n * @param fn the function to run for each childs if the function return `false` it will stop\n * @returns {boolean} return if the loop finished or ended early\n */\nexport function objectLoop<T = any, K extends BasicObjectKeys = BasicObjectKeys>(\n\tobj: BasicObject<K, T>,\n\tfn: (value: T, key: K, index: number) => boolean | void\n): boolean {\n\tmustBeObject(obj)\n\n\t// get the object keys\n\tconst keys = objectKeys(obj)\n\n\t// loop trough each keys\n\tfor (let index = 0; index < keys.length; index++) {\n\t\tconst key = keys[index]\n\t\tconst stop = fn(obj[key] as T, key as K, index)\n\t\tif (stop === false) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n/**\n * Transform an object to an array of its values\n *\n * @param obj the object to transform\n * @returns {Array} an array containing the object's values\n */\nexport function objectValues<T = any>(obj: BasicObject<BasicObjectKeys, T>): Array<T> {\n\tmustBeObject(obj)\n\treturn Object.values(obj) as Array<T>\n}\n\n/**\n * @deprecated use `objectValues`\n */\nexport function objectToArray<T = any>(obj: BasicObject<BasicObjectKeys, T>): Array<T> {\n\tmustBeObject(obj)\n\treturn objectValues(obj)\n}\n\n/**\n * return the keys of the object\n *\n * @param obj the object\n * @returns {Array} an array containing the object's keys\n */\nexport function objectKeys<K extends BasicObjectKeys = BasicObjectKeys>(obj: BasicObject<K>): Array<K> {\n\tmustBeObject(obj)\n\n\t// Handle arrays\n\tif (Array.isArray(obj)) {\n\t\treturn Array.from(obj.keys()) as Array<K>\n\t}\n\treturn Object.keys(obj) as Array<K>\n}\n\n/**\n * return the length of an object\n *\n * @param obj the object\n * @returns {number} the object's size\n */\nexport function objectSize(obj: BasicObject): number {\n\treturn objectKeys(obj).length\n}\n\n/**\n * Sort an object by its keys\n *\n * Same as Array.sort but for objects\n *\n * @param obj the object to sort\n * @param fn (Optionnal) the function to run to sort\n * @returns a new object with the keys sorted using the fn\n */\nexport function objectSort<T extends BasicObject>(\n\tobj: T,\n\tfn?: Array<keyof T> | ((a: keyof T, b: keyof T) => number)\n): T {\n\tmustBeObject(obj)\n\tconst ordered: any = {}\n\tlet sortedKeys: Array<keyof T> = []\n\tif (Array.isArray(fn)) {\n\t\tsortedKeys = fn.concat(objectKeys(obj).filter((key) => !fn.includes(key)))\n\t} else {\n\t\tsortedKeys = objectKeys(obj).sort(fn)\n\t}\n\tfor (const key of sortedKeys) {\n\t\tordered[key] = obj[key]\n\t}\n\treturn ordered\n}\n\n/**\n * @deprecated use `objectClone`\n */\nexport function cloneObject<T extends BasicObject>(obj: T): T {\n\treturn objectClone(obj)\n}\n\n/**\n * Deeply clone an object\n *\n * @param obj the object to clone\n * @param options Cloning options\n * @param options.deep (Default: true) deeply clone the object\n * @returns the clone of the object\n */\nexport function objectClone<T extends BasicObject>(obj: T, options?: {deep?: boolean}): T {\n\tmustBeObject(obj)\n\tif (Array.isArray(obj)) {\n\t\tconst arr: Array<any> = []\n\t\tfor (const item of obj) {\n\t\t\tarr.push(\n\t\t\t\tisObject(item) ? objectClone(item) : item\n\t\t\t)\n\t\t}\n\t\treturn arr as unknown as T\n\t}\n\tconst clone: Partial<T> = {}\n\tobjectLoop(obj, (value, key) => {\n\t\tif (typeof value === 'object' && value != null && (typeof options?.deep === 'undefined' || options.deep)) {\n\t\t\tclone[key as Extract<keyof T, string>] = objectClone(value)\n\t\t\treturn\n\t\t}\n\t\tclone[key as Extract<keyof T, string>] = value\n\t})\n\treturn clone as T\n}\n\n/**\n * deeply set the value at the path given\n *\n * (Create sub object/array if not made depending on path type (number = Array, string = Object))\n *\n * _NOTE: it is way quicker to use `obj[path][path]... = value` when possible_\n *\n * @param obj the object to set the value\n * @param path the path\n * @param value the value\n */\nexport function objectSet(obj: BasicObject, path: Array<BasicObjectKeys>, value: any): void {\n\tmustBeObject(obj)\n\tlet pointer = obj\n\tfor (let index = 0; index < path.length; index++) {\n\t\tconst key = path[index]\n\t\tconst nextIndex = index + 1\n\t\tif (!Object.prototype.hasOwnProperty.call(pointer, key) && nextIndex < path.length) {\n\t\t\tconst key1 = path[nextIndex]\n\t\t\tif (typeof key1 === 'number') {\n\t\t\t\tpointer[key] = []\n\t\t\t} else {\n\t\t\t\tpointer[key] = {}\n\t\t\t}\n\t\t}\n\n\t\t// if last index\n\t\tif (nextIndex === path.length) {\n\t\t\tpointer[key] = value\n\t\t\tif (value === undefined) {\n\t\t\t\tdelete pointer[key]\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\t// move pointer to new key\n\t\tpointer = pointer[key]\n\t}\n}\n\n/**\n * deeply compare objects and return if they are equal or not\n *\n * @param first the first object\n * @param second the second object\n * @returns {boolean} a boolean representing the equality of the two objects\n */\nexport function objectEqual(first: BasicObject, second: BasicObject): boolean {\n\tmustBeObject(first)\n\tmustBeObject(second)\n\tif (objectSize(first) !== objectSize(second)) {\n\t\treturn false\n\t}\n\tconst res = objectLoop(first, (item, key) => {\n\t\tif (!(key in second) && key in first) {\n\t\t\treturn false\n\t\t}\n\t\tconst item2 = second[key]\n\t\tif (item === null && item2 === null) {\n\t\t\treturn true\n\t\t}\n\t\tif (typeof item === 'object' && typeof item2 === 'object') {\n\t\t\treturn objectEqual(item, item2)\n\t\t}\n\t\treturn item === item2\n\t})\n\treturn res\n}\n\n/**\n * Deeply clean an object from having `undefined`,`null` and/or flasy values (options to enable)\n *\n * @param obj the object to clean\n * @param options cleanup options\n * @param {boolean?} options.cleanUndefined (default: true) clean undefined from the object\n * @param {boolean?} options.cleanFalsy (default: false) clean falsy values (including undefined and null) from the object see https://developer.mozilla.org/en-US/docs/Glossary/Falsy\n * @param {boolean?} options.cleanNull (default: false) clean null from the object\n * @param {boolean?} options.deep (default: true) deeply clean the object\n */\nexport function objectClean(obj: BasicObject, options?: {cleanUndefined?: boolean, cleanNull?: boolean, cleanFalsy?: boolean, deep?: boolean}): void {\n\tmustBeObject(obj)\n\tobjectLoop(obj, (item, key) => {\n\t\tif ((typeof options?.cleanUndefined === 'undefined' || options.cleanUndefined) && item === undefined) {\n\t\t\tdelete obj[key] // clean undefined values\n\t\t} else if (options?.cleanFalsy && !obj[key]) {\n\t\t\tdelete obj[key] // clean falsy values\n\t\t} else if (options?.cleanNull && item === null) {\n\t\t\tdelete obj[key] // clean null values\n\t\t}\n\n\t\t// deeply clean the object\n\t\tif ((typeof options?.deep === 'undefined' || options.deep) && isObject(item)) {\n\t\t\tobjectClean(item, options)\n\t\t}\n\t})\n}\n\n/**\n * return a new object containing only not the keys defined\n *\n * note: clone is not deep\n *\n * @param obj the object to clone\n * @param keys the keys to emit\n * @returns the cloned object\n */\nexport function objectOmit<T extends BasicObject>(obj: T, ...keys: Array<string | number>): T {\n\tconst cloned = objectClone(obj, {deep: false})\n\tfor (const key of keys) {\n\t\tif (key in cloned) {\n\t\t\tdelete cloned[key]\n\t\t}\n\t}\n\treturn cloned\n}\n\n/**\n * find an element in an object\n *\n * @param obj the object to find within\n * @param fn the function that find the object\n * @returns the key, value, index of the element found or undefined\n */\nexport function objectFind<T = any, K extends BasicObjectKeys = BasicObjectKeys>(\n\tobj: BasicObject<K, T>,\n\tfn: (value: T, key: K, index: number) => boolean\n): {key: K, value: T} | undefined {\n\tmustBeObject(obj)\n\tlet res: {key: K, value: T, index: number} | undefined = undefined\n\tobjectLoop(obj, (value, key, index) => {\n\t\tconst tmp = fn(value, key, index)\n\t\tif (tmp) {\n\t\t\tres = {\n\t\t\t\tkey, value, index\n\t\t\t}\n\t\t}\n\t\treturn !tmp\n\t})\n\treturn res\n}\n\n/**\n * go through an object to get a specific value\n *\n * note: it will be slower than getting it directly (ex: `obj['pouet']`)\n *\n * @param obj the object to go through\n * @param {Array<string | number | symbol> | string} path the path to follow (if path is a string it will be splitted with `.` and ints will be parsed)\n *\n * @returns the value if found or undefined if it was not found\n */\nexport function objectGet<T = any>(obj: any, path: Array<string | number | symbol> | string): T | undefined {\n\t// if path is not defined or path is empty return the current object\n\tif (!path || path === '' || Array.isArray(path) && path.length === 0) {\n\t\treturn obj as T\n\t}\n\n\tmustBeObject(obj)\n\n\t// transform path into an Array\n\tif (typeof path === 'string') {\n\t\tpath = path.split('.').map((it) => /^\\d+$/g.test(it) ? Number.parseInt(it) : it)\n\t}\n\n\t// the pointer\n\tlet pointer: object = obj\n\n\t// loop through each keys\n\tfor (let index = 0; index < path.length; index++) {\n\t\tconst key = path[index]\n\t\tconst nextIndex = index + 1;\n\n\t\t// handle key being undefined or pointer not having key and not the last key\n\t\tif (typeof key === 'undefined' || !Object.prototype.hasOwnProperty.call(pointer, key) && nextIndex < path.length) {\n\t\t\treturn undefined\n\t\t}\n\n\t\t// if last index\n\t\tif (nextIndex === path.length) {\n\t\t\treturn (pointer as any)[key] as T\n\t\t}\n\n\t\t// move pointer to new key\n\t\tpointer = (pointer as any)[key]\n\t}\n\n\tthrow new Error(`it should never get there ! (${JSON.stringify(obj)}, ${path}, ${JSON.stringify(pointer)})`)\n}\n\n/**\n * return if an item is an object\n *\n * @param item the item to check\n * @returns {boolean} the item is an object\n */\nexport function isObject(item: any): item is BasicObject {\n\treturn typeof item === 'object' && item !== null\n}\n\n/**\n * Strict check for an object\n *\n * throw an error is the item is not an item\n *\n * @param item the item to check\n * @returns {boolean} true is the item is an object, else throw an error\n */\nexport function mustBeObject(item: any): item is BasicObject {\n\tif (!isObject(item)) {\n\t\tthrow new Error('Input is not an object!')\n\t}\n\treturn true\n}\n\nexport default {\n\tobjectClean,\n\tobjectClone,\n\tobjectEqual,\n\tobjectFind,\n\tobjectGet,\n\tobjectKeys,\n\tobjectLoop,\n\tobjectMap,\n\tobjectOmit,\n\tobjectRemap,\n\tobjectSet,\n\tobjectSize,\n\tobjectSort,\n\n\t// helpers\n\tisObject,\n\tmustBeObject,\n\n\t// deprecated\n\tobjectToArray,\n\tcloneObject,\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYO,WAAS,UACf,KACA,IACW;AACX,iBAAa,GAAG;AAChB,UAAM,OAAiB,CAAC;AACxB,eAAW,KAAK,CAAC,MAAM,KAAK,UAAU;AACrC,WAAK,KAAK,GAAG,MAAM,KAAK,KAAK,CAAC;AAAA,IAC/B,CAAC;AACD,WAAO;AAAA,EACR;AAiBO,WAAS,YACf,KACA,IACA,SACI;AACJ,iBAAa,GAAG;AAGhB,UAAM,QAAW,CAAC;AAGlB,eAAW,KAAK,CAAC,MAAM,QAAQ,UAAU;AACxC,YAAM,EAAE,KAAK,MAAM,IAAI,GAAG,MAAM,QAAQ,KAAK;AAC7C,WAAI,mCAAS,WAAU,OAAO,OAAO;AACpC,cAAM,IAAI,MAAM,oEAAqE;AAAA,MACtF;AAGA,YAAM,GAAG,IAAI;AAAA,IACd,CAAC;AACD,WAAO;AAAA,EACR;AASO,WAAS,WACf,KACA,IACU;AACV,iBAAa,GAAG;AAGhB,UAAM,OAAO,WAAW,GAAG;AAG3B,aAAS,QAAQ,GAAG,QAAQ,KAAK,QAAQ,SAAS;AACjD,YAAM,MAAM,KAAK,KAAK;AACtB,YAAM,OAAO,GAAG,IAAI,GAAG,GAAQ,KAAU,KAAK;AAC9C,UAAI,SAAS,OAAO;AACnB,eAAO;AAAA,MACR;AAAA,IACD;AACA,WAAO;AAAA,EACR;AAQO,WAAS,aAAsB,KAAgD;AACrF,iBAAa,GAAG;AAChB,WAAO,OAAO,OAAO,GAAG;AAAA,EACzB;AAKO,WAAS,cAAuB,KAAgD;AACtF,iBAAa,GAAG;AAChB,WAAO,aAAa,GAAG;AAAA,EACxB;AAQO,WAAS,WAAwD,KAA+B;AACtG,iBAAa,GAAG;AAGhB,QAAI,MAAM,QAAQ,GAAG,GAAG;AACvB,aAAO,MAAM,KAAK,IAAI,KAAK,CAAC;AAAA,IAC7B;AACA,WAAO,OAAO,KAAK,GAAG;AAAA,EACvB;AAQO,WAAS,WAAW,KAA0B;AACpD,WAAO,WAAW,GAAG,EAAE;AAAA,EACxB;AAWO,WAAS,WACf,KACA,IACI;AACJ,iBAAa,GAAG;AAChB,UAAM,UAAe,CAAC;AACtB,QAAI,aAA6B,CAAC;AAClC,QAAI,MAAM,QAAQ,EAAE,GAAG;AACtB,mBAAa,GAAG,OAAO,WAAW,GAAG,EAAE,OAAO,CAAC,QAAQ,CAAC,GAAG,SAAS,GAAG,CAAC,CAAC;AAAA,IAC1E,OAAO;AACN,mBAAa,WAAW,GAAG,EAAE,KAAK,EAAE;AAAA,IACrC;AACA,eAAW,OAAO,YAAY;AAC7B,cAAQ,GAAG,IAAI,IAAI,GAAG;AAAA,IACvB;AACA,WAAO;AAAA,EACR;AAKO,WAAS,YAAmC,KAAW;AAC7D,WAAO,YAAY,GAAG;AAAA,EACvB;AAUO,WAAS,YAAmC,KAAQ,SAA+B;AACzF,iBAAa,GAAG;AAChB,QAAI,MAAM,QAAQ,GAAG,GAAG;AACvB,YAAM,MAAkB,CAAC;AACzB,iBAAW,QAAQ,KAAK;AACvB,YAAI;AAAA,UACH,SAAS,IAAI,IAAI,YAAY,IAAI,IAAI;AAAA,QACtC;AAAA,MACD;AACA,aAAO;AAAA,IACR;AACA,UAAM,QAAoB,CAAC;AAC3B,eAAW,KAAK,CAAC,OAAO,QAAQ;AAC/B,UAAI,OAAO,UAAU,YAAY,SAAS,SAAS,QAAO,mCAAS,UAAS,eAAe,QAAQ,OAAO;AACzG,cAAM,GAA+B,IAAI,YAAY,KAAK;AAC1D;AAAA,MACD;AACA,YAAM,GAA+B,IAAI;AAAA,IAC1C,CAAC;AACD,WAAO;AAAA,EACR;AAaO,WAAS,UAAU,KAAkB,MAA8B,OAAkB;AAC3F,iBAAa,GAAG;AAChB,QAAI,UAAU;AACd,aAAS,QAAQ,GAAG,QAAQ,KAAK,QAAQ,SAAS;AACjD,YAAM,MAAM,KAAK,KAAK;AACtB,YAAM,YAAY,QAAQ;AAC1B,UAAI,CAAC,OAAO,UAAU,eAAe,KAAK,SAAS,GAAG,KAAK,YAAY,KAAK,QAAQ;AACnF,cAAM,OAAO,KAAK,SAAS;AAC3B,YAAI,OAAO,SAAS,UAAU;AAC7B,kBAAQ,GAAG,IAAI,CAAC;AAAA,QACjB,OAAO;AACN,kBAAQ,GAAG,IAAI,CAAC;AAAA,QACjB;AAAA,MACD;AAGA,UAAI,cAAc,KAAK,QAAQ;AAC9B,gBAAQ,GAAG,IAAI;AACf,YAAI,UAAU,QAAW;AACxB,iBAAO,QAAQ,GAAG;AAAA,QACnB;AACA;AAAA,MACD;AAGA,gBAAU,QAAQ,GAAG;AAAA,IACtB;AAAA,EACD;AASO,WAAS,YAAY,OAAoB,QAA8B;AAC7E,iBAAa,KAAK;AAClB,iBAAa,MAAM;AACnB,QAAI,WAAW,KAAK,MAAM,WAAW,MAAM,GAAG;AAC7C,aAAO;AAAA,IACR;AACA,UAAM,MAAM,WAAW,OAAO,CAAC,MAAM,QAAQ;AAC5C,UAAI,EAAE,OAAO,WAAW,OAAO,OAAO;AACrC,eAAO;AAAA,MACR;AACA,YAAM,QAAQ,OAAO,GAAG;AACxB,UAAI,SAAS,QAAQ,UAAU,MAAM;AACpC,eAAO;AAAA,MACR;AACA,UAAI,OAAO,SAAS,YAAY,OAAO,UAAU,UAAU;AAC1D,eAAO,YAAY,MAAM,KAAK;AAAA,MAC/B;AACA,aAAO,SAAS;AAAA,IACjB,CAAC;AACD,WAAO;AAAA,EACR;AAYO,WAAS,YAAY,KAAkB,SAAuG;AACpJ,iBAAa,GAAG;AAChB,eAAW,KAAK,CAAC,MAAM,QAAQ;AAC9B,WAAK,QAAO,mCAAS,oBAAmB,eAAe,QAAQ,mBAAmB,SAAS,QAAW;AACrG,eAAO,IAAI,GAAG;AAAA,MACf,YAAW,mCAAS,eAAc,CAAC,IAAI,GAAG,GAAG;AAC5C,eAAO,IAAI,GAAG;AAAA,MACf,YAAW,mCAAS,cAAa,SAAS,MAAM;AAC/C,eAAO,IAAI,GAAG;AAAA,MACf;AAGA,WAAK,QAAO,mCAAS,UAAS,eAAe,QAAQ,SAAS,SAAS,IAAI,GAAG;AAC7E,oBAAY,MAAM,OAAO;AAAA,MAC1B;AAAA,IACD,CAAC;AAAA,EACF;AAWO,WAAS,WAAkC,QAAW,MAAiC;AAC7F,UAAM,SAAS,YAAY,KAAK,EAAC,MAAM,MAAK,CAAC;AAC7C,eAAW,OAAO,MAAM;AACvB,UAAI,OAAO,QAAQ;AAClB,eAAO,OAAO,GAAG;AAAA,MAClB;AAAA,IACD;AACA,WAAO;AAAA,EACR;AASO,WAAS,WACf,KACA,IACiC;AACjC,iBAAa,GAAG;AAChB,QAAI,MAAqD;AACzD,eAAW,KAAK,CAAC,OAAO,KAAK,UAAU;AACtC,YAAM,MAAM,GAAG,OAAO,KAAK,KAAK;AAChC,UAAI,KAAK;AACR,cAAM;AAAA,UACL;AAAA,UAAK;AAAA,UAAO;AAAA,QACb;AAAA,MACD;AACA,aAAO,CAAC;AAAA,IACT,CAAC;AACD,WAAO;AAAA,EACR;AAYO,WAAS,UAAmB,KAAU,MAA+D;AAE3G,QAAI,CAAC,QAAQ,SAAS,MAAM,MAAM,QAAQ,IAAI,KAAK,KAAK,WAAW,GAAG;AACrE,aAAO;AAAA,IACR;AAEA,iBAAa,GAAG;AAGhB,QAAI,OAAO,SAAS,UAAU;AAC7B,aAAO,KAAK,MAAM,GAAG,EAAE,IAAI,CAAC,OAAO,SAAS,KAAK,EAAE,IAAI,OAAO,SAAS,EAAE,IAAI,EAAE;AAAA,IAChF;AAGA,QAAI,UAAkB;AAGtB,aAAS,QAAQ,GAAG,QAAQ,KAAK,QAAQ,SAAS;AACjD,YAAM,MAAM,KAAK,KAAK;AACtB,YAAM,YAAY,QAAQ;AAG1B,UAAI,OAAO,QAAQ,eAAe,CAAC,OAAO,UAAU,eAAe,KAAK,SAAS,GAAG,KAAK,YAAY,KAAK,QAAQ;AACjH,eAAO;AAAA,MACR;AAGA,UAAI,cAAc,KAAK,QAAQ;AAC9B,eAAQ,QAAgB,GAAG;AAAA,MAC5B;AAGA,gBAAW,QAAgB,GAAG;AAAA,IAC/B;AAEA,UAAM,IAAI,MAAM,gCAAgC,KAAK,UAAU,GAAG,CAAC,KAAK,IAAI,KAAK,KAAK,UAAU,OAAO,CAAC,GAAG;AAAA,EAC5G;AAQO,WAAS,SAAS,MAAgC;AACxD,WAAO,OAAO,SAAS,YAAY,SAAS;AAAA,EAC7C;AAUO,WAAS,aAAa,MAAgC;AAC5D,QAAI,CAAC,SAAS,IAAI,GAAG;AACpB,YAAM,IAAI,MAAM,yBAAyB;AAAA,IAC1C;AACA,WAAO;AAAA,EACR;AAEA,MAAO,qBAAQ;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA,IAGA;AAAA,IACA;AAAA;AAAA,IAGA;AAAA,IACA;AAAA,EACD;","names":[]}