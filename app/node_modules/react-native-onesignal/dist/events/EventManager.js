"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_native_1 = require("react-native");
var NotificationWillDisplayEvent_1 = __importDefault(require("./NotificationWillDisplayEvent"));
var events_1 = require("./events");
var eventList = [
    events_1.PERMISSION_CHANGED,
    events_1.SUBSCRIPTION_CHANGED,
    events_1.USER_STATE_CHANGED,
    events_1.NOTIFICATION_WILL_DISPLAY,
    events_1.NOTIFICATION_CLICKED,
    events_1.IN_APP_MESSAGE_CLICKED,
    events_1.IN_APP_MESSAGE_WILL_DISPLAY,
    events_1.IN_APP_MESSAGE_WILL_DISMISS,
    events_1.IN_APP_MESSAGE_DID_DISMISS,
    events_1.IN_APP_MESSAGE_DID_DISPLAY,
];
var EventManager = /** @class */ (function () {
    function EventManager(RNOneSignal) {
        this.RNOneSignal = RNOneSignal;
        this.oneSignalEventEmitter = new react_native_1.NativeEventEmitter(RNOneSignal);
        this.eventListenerArrayMap = new Map(); // used for adders (multiple callbacks possible)
        this.listeners = {};
        this.setupListeners();
    }
    EventManager.prototype.setupListeners = function () {
        // set up the event emitter and listeners
        if (this.RNOneSignal != null) {
            for (var i = 0; i < eventList.length; i++) {
                var eventName = eventList[i];
                this.listeners[eventName] = this.generateEventListener(eventName);
            }
        }
    };
    /**
     * Adds the event handler to the corresponding handler array on the JS side of the bridge
     * @param  {string} eventName
     * @param  {function} handler
     * @returns void
     */
    EventManager.prototype.addEventListener = function (eventName, handler) {
        var handlerArray = this.eventListenerArrayMap.get(eventName);
        handlerArray && handlerArray.length > 0
            ? handlerArray.push(handler)
            : this.eventListenerArrayMap.set(eventName, [handler]);
    };
    /**
     * clears the event handler(s) for the event name
     * @param  {string} eventName
     * @param  {function} handler
     * @returns void
     */
    EventManager.prototype.removeEventListener = function (eventName, handler) {
        var handlerArray = this.eventListenerArrayMap.get(eventName);
        if (!handlerArray) {
            return;
        }
        var index = handlerArray.indexOf(handler);
        if (index !== -1) {
            handlerArray.splice(index, 1);
        }
        if (handlerArray.length === 0) {
            this.eventListenerArrayMap.delete(eventName);
        }
    };
    // returns an event listener with the js to native mapping
    EventManager.prototype.generateEventListener = function (eventName) {
        var _this = this;
        var addListenerCallback = function (payload) {
            var handlerArray = _this.eventListenerArrayMap.get(eventName);
            if (handlerArray) {
                if (eventName === events_1.NOTIFICATION_WILL_DISPLAY) {
                    handlerArray.forEach(function (handler) {
                        handler(new NotificationWillDisplayEvent_1.default(payload));
                    });
                }
                else if (eventName === events_1.PERMISSION_CHANGED) {
                    var typedPayload_1 = payload;
                    handlerArray.forEach(function (handler) {
                        handler(typedPayload_1.permission);
                    });
                }
                else {
                    handlerArray.forEach(function (handler) {
                        handler(payload);
                    });
                }
            }
        };
        return this.oneSignalEventEmitter.addListener(eventName, addListenerCallback);
    };
    return EventManager;
}());
exports.default = EventManager;
