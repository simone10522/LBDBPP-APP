'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OSNotificationPermission = exports.NotificationWillDisplayEvent = exports.OneSignal = exports.LogLevel = void 0;
var react_native_1 = require("react-native");
var EventManager_1 = __importDefault(require("./events/EventManager"));
var events_1 = require("./events/events");
var Subscription_1 = require("./models/Subscription");
Object.defineProperty(exports, "OSNotificationPermission", { enumerable: true, get: function () { return Subscription_1.OSNotificationPermission; } });
var NotificationWillDisplayEvent_1 = __importDefault(require("./events/NotificationWillDisplayEvent"));
exports.NotificationWillDisplayEvent = NotificationWillDisplayEvent_1.default;
var helpers_1 = require("./helpers");
var RNOneSignal = react_native_1.NativeModules.OneSignal;
var eventManager = new EventManager_1.default(RNOneSignal);
/// An enum that declares different types of log levels you can use with the OneSignal SDK, going from the least verbose (none) to verbose (print all comments).
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["None"] = 0] = "None";
    LogLevel[LogLevel["Fatal"] = 1] = "Fatal";
    LogLevel[LogLevel["Error"] = 2] = "Error";
    LogLevel[LogLevel["Warn"] = 3] = "Warn";
    LogLevel[LogLevel["Info"] = 4] = "Info";
    LogLevel[LogLevel["Debug"] = 5] = "Debug";
    LogLevel[LogLevel["Verbose"] = 6] = "Verbose";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
// Internal wrapper notification permission state that is being updated by the permission change handler.
var notificationPermission = false;
// Internal wrapper push subscription state that is being updated by the subscription change handler.
var pushSub = {
    id: '',
    token: '',
    optedIn: false,
};
function _addPermissionObserver() {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    OneSignal.Notifications.addEventListener('permissionChange', function (granted) {
                        notificationPermission = granted;
                    });
                    return [4 /*yield*/, RNOneSignal.hasNotificationPermission()];
                case 1:
                    notificationPermission = _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
function _addPushSubscriptionObserver() {
    return __awaiter(this, void 0, void 0, function () {
        var _a, _b, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    OneSignal.User.pushSubscription.addEventListener('change', function (subscriptionChange) {
                        pushSub = subscriptionChange.current;
                    });
                    _a = pushSub;
                    return [4 /*yield*/, RNOneSignal.getPushSubscriptionId()];
                case 1:
                    _a.id = _d.sent();
                    _b = pushSub;
                    return [4 /*yield*/, RNOneSignal.getPushSubscriptionToken()];
                case 2:
                    _b.token = _d.sent();
                    _c = pushSub;
                    return [4 /*yield*/, RNOneSignal.getOptedIn()];
                case 3:
                    _c.optedIn = _d.sent();
                    return [2 /*return*/];
            }
        });
    });
}
var OneSignal;
(function (OneSignal) {
    /** Initializes the OneSignal SDK. This should be called during startup of the application. */
    function initialize(appId) {
        if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
            return;
        RNOneSignal.initialize(appId);
        _addPermissionObserver();
        _addPushSubscriptionObserver();
    }
    OneSignal.initialize = initialize;
    /**
     * If your integration is user-centric, or you want the ability to identify the user beyond the current device, the
     * login method should be called to identify the user.
     */
    function login(externalId) {
        if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
            return;
        RNOneSignal.login(externalId);
    }
    OneSignal.login = login;
    /**
     * Once (or if) the user is no longer identifiable in your app (i.e. they logged out), the logout method should be
     * called.
     */
    function logout() {
        if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
            return;
        RNOneSignal.logout();
    }
    OneSignal.logout = logout;
    /** For GDPR users, your application should call this method before setting the App ID. */
    function setConsentRequired(required) {
        if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
            return;
        RNOneSignal.setPrivacyConsentRequired(required);
    }
    OneSignal.setConsentRequired = setConsentRequired;
    /**
     * If your application is set to require the user's privacy consent, you can provide this consent using this method.
     * Indicates whether privacy consent has been granted. This field is only relevant when the application has opted
     * into data privacy protections.
     */
    function setConsentGiven(granted) {
        if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
            return;
        RNOneSignal.setPrivacyConsentGiven(granted);
    }
    OneSignal.setConsentGiven = setConsentGiven;
    var Debug;
    (function (Debug) {
        /**
         * Enable logging to help debug if you run into an issue setting up OneSignal.
         * @param {LogLevel} nsLogLevel - Sets the logging level to print to the Android LogCat log or Xcode log.
         */
        function setLogLevel(nsLogLevel) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.setLogLevel(nsLogLevel);
        }
        Debug.setLogLevel = setLogLevel;
        /**
         * Enable logging to help debug if you run into an issue setting up OneSignal.
         * @param {LogLevel} visualLogLevel - Sets the logging level to show as alert dialogs.
         */
        function setAlertLevel(visualLogLevel) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.setAlertLevel(visualLogLevel);
        }
        Debug.setAlertLevel = setAlertLevel;
    })(Debug = OneSignal.Debug || (OneSignal.Debug = {}));
    var LiveActivities;
    (function (LiveActivities) {
        /**
         * Indicate this device has exited a live activity, identified within OneSignal by the `activityId`.
         *
         * Only applies to iOS
         *
         * @param activityId: The activity identifier the live activity on this device will receive updates for.
         * @param token: The activity's update token to receive the updates.
         **/
        function enter(activityId, token, handler) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            if (!handler) {
                handler = function () { };
            }
            // Only Available on iOS
            if (react_native_1.Platform.OS === 'ios') {
                RNOneSignal.enterLiveActivity(activityId, token, handler);
            }
        }
        LiveActivities.enter = enter;
        /**
         * Indicate this device has exited a live activity, identified within OneSignal by the `activityId`.
         *
         * Only applies to iOS
         *
         * @param activityId: The activity identifier the live activity on this device will no longer receive updates for.
         **/
        function exit(activityId, handler) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            if (!handler) {
                handler = function () { };
            }
            if (react_native_1.Platform.OS === 'ios') {
                RNOneSignal.exitLiveActivity(activityId, handler);
            }
        }
        LiveActivities.exit = exit;
        /**
         * Indicate this device is capable of receiving pushToStart live activities for the
         * `activityType`. The `activityType` **must** be the name of the struct conforming
         * to `ActivityAttributes` that will be used to start the live activity.
         *
         * Only applies to iOS
         *
         * @param activityType: The name of the specific `ActivityAttributes` structure tied
         * to the live activity.
         * @param token: The activity type's pushToStart token.
         */
        function setPushToStartToken(activityType, token) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            if (react_native_1.Platform.OS === 'ios') {
                RNOneSignal.setPushToStartToken(activityType, token);
            }
        }
        LiveActivities.setPushToStartToken = setPushToStartToken;
        /**
         * Indicate this device is no longer capable of receiving pushToStart live activities
         * for the `activityType`. The `activityType` **must** be the name of the struct conforming
         * to `ActivityAttributes` that will be used to start the live activity.
         *
         * Only applies to iOS
         *
         * @param activityType: The name of the specific `ActivityAttributes` structure tied
         * to the live activity.
         */
        function removePushToStartToken(activityType) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            if (react_native_1.Platform.OS === 'ios') {
                RNOneSignal.removePushToStartToken(activityType);
            }
        }
        LiveActivities.removePushToStartToken = removePushToStartToken;
        /**
         * Enable the OneSignalSDK to setup the default`DefaultLiveActivityAttributes` structure,
         * which conforms to the `OneSignalLiveActivityAttributes`. When using this function, the
         * widget attributes are owned by the OneSignal SDK, which will allow the SDK to handle the
         * entire lifecycle of the live activity.  All that is needed from an app-perspective is to
         * create a Live Activity widget in a widget extension, with a `ActivityConfiguration` for
         * `DefaultLiveActivityAttributes`. This is most useful for users that (1) only have one Live
         * Activity widget and (2) are using a cross-platform framework and do not want to create the
         * cross-platform <-> iOS native bindings to manage ActivityKit.
         *
         * Only applies to iOS
         *
         * @param options: An optional structure to provide for more granular setup options.
         */
        function setupDefault(options) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            if (react_native_1.Platform.OS === 'ios') {
                RNOneSignal.setupDefaultLiveActivity(options);
            }
        }
        LiveActivities.setupDefault = setupDefault;
        /**
         * Start a new LiveActivity that is modelled by the default`DefaultLiveActivityAttributes`
         * structure. The `DefaultLiveActivityAttributes` is initialized with the dynamic `attributes`
         * and `content` passed in.
         *
         * Only applies to iOS
         *
         * @param activityId: The activity identifier the live activity on this device will be started
         * and eligible to receive updates for.
         * @param attributes: A dynamic type containing the static attributes passed into `DefaultLiveActivityAttributes`.
         * @param content: A dynamic type containing the content attributes passed into `DefaultLiveActivityAttributes`.
         */
        function startDefault(activityId, attributes, content) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            if (react_native_1.Platform.OS === 'ios') {
                RNOneSignal.startDefaultLiveActivity(activityId, attributes, content);
            }
        }
        LiveActivities.startDefault = startDefault;
    })(LiveActivities = OneSignal.LiveActivities || (OneSignal.LiveActivities = {}));
    var User;
    (function (User) {
        var pushSubscription;
        (function (pushSubscription) {
            /** Add a callback that fires when the OneSignal subscription state changes. */
            function addEventListener(event, listener) {
                if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                    return;
                helpers_1.isValidCallback(listener);
                RNOneSignal.addPushSubscriptionObserver();
                eventManager.addEventListener(events_1.SUBSCRIPTION_CHANGED, listener);
            }
            pushSubscription.addEventListener = addEventListener;
            /** Clears current subscription observers. */
            function removeEventListener(event, listener) {
                if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                    return;
                eventManager.removeEventListener(events_1.SUBSCRIPTION_CHANGED, listener);
            }
            pushSubscription.removeEventListener = removeEventListener;
            /**
             * @deprecated This method is deprecated. It has been replaced by {@link getIdAsync}.
             */
            function getPushSubscriptionId() {
                if (!helpers_1.isNativeModuleLoaded(RNOneSignal)) {
                    return '';
                }
                console.warn('OneSignal: This method has been deprecated. Use getIdAsync instead for getting push subscription id.');
                return pushSub.id ? pushSub.id : '';
            }
            pushSubscription.getPushSubscriptionId = getPushSubscriptionId;
            function getIdAsync() {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!helpers_1.isNativeModuleLoaded(RNOneSignal)) {
                                    return [2 /*return*/, Promise.reject(new Error('OneSignal native module not loaded'))];
                                }
                                return [4 /*yield*/, RNOneSignal.getPushSubscriptionId()];
                            case 1: return [2 /*return*/, _a.sent()];
                        }
                    });
                });
            }
            pushSubscription.getIdAsync = getIdAsync;
            /**
             * @deprecated This method is deprecated. It has been replaced by {@link getTokenAsync}.
             */
            function getPushSubscriptionToken() {
                if (!helpers_1.isNativeModuleLoaded(RNOneSignal)) {
                    return '';
                }
                console.warn('OneSignal: This method has been deprecated. Use getTokenAsync instead for getting push subscription token.');
                return pushSub.token ? pushSub.token : '';
            }
            pushSubscription.getPushSubscriptionToken = getPushSubscriptionToken;
            /** The readonly push subscription token */
            function getTokenAsync() {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!helpers_1.isNativeModuleLoaded(RNOneSignal)) {
                                    return [2 /*return*/, Promise.reject(new Error('OneSignal native module not loaded'))];
                                }
                                return [4 /*yield*/, RNOneSignal.getPushSubscriptionToken()];
                            case 1: return [2 /*return*/, _a.sent()];
                        }
                    });
                });
            }
            pushSubscription.getTokenAsync = getTokenAsync;
            /**
             * @deprecated This method is deprecated. It has been replaced by {@link getOptedInAsync}.
             */
            function getOptedIn() {
                if (!helpers_1.isNativeModuleLoaded(RNOneSignal)) {
                    return false;
                }
                console.warn('OneSignal: This method has been deprecated. Use getOptedInAsync instead for getting push subscription opted in status.');
                return pushSub.optedIn;
            }
            pushSubscription.getOptedIn = getOptedIn;
            /**
             * Gets a boolean value indicating whether the current user is opted in to push notifications.
             * This returns true when the app has notifications permission and optOut is not called.
             * Note: Does not take into account the existence of the subscription ID and push token.
             * This boolean may return true but push notifications may still not be received by the user.
             */
            function getOptedInAsync() {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!helpers_1.isNativeModuleLoaded(RNOneSignal)) {
                                    return [2 /*return*/, Promise.reject(new Error('OneSignal native module not loaded'))];
                                }
                                return [4 /*yield*/, RNOneSignal.getOptedIn()];
                            case 1: return [2 /*return*/, _a.sent()];
                        }
                    });
                });
            }
            pushSubscription.getOptedInAsync = getOptedInAsync;
            /** Disable the push notification subscription to OneSignal. */
            function optOut() {
                if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                    return;
                RNOneSignal.optOut();
            }
            pushSubscription.optOut = optOut;
            /** Enable the push notification subscription to OneSignal. */
            function optIn() {
                if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                    return;
                RNOneSignal.optIn();
            }
            pushSubscription.optIn = optIn;
        })(pushSubscription = User.pushSubscription || (User.pushSubscription = {}));
        /**
         * Add a callback that fires when the OneSignal user state changes.
         * Important: When using the observer to retrieve the onesignalId, check the externalId as well to confirm the values are associated with the expected user.
         */
        function addEventListener(event, listener) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            helpers_1.isValidCallback(listener);
            RNOneSignal.addUserStateObserver();
            eventManager.addEventListener(events_1.USER_STATE_CHANGED, listener);
        }
        User.addEventListener = addEventListener;
        /** Clears current user state observers. */
        function removeEventListener(event, listener) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            eventManager.removeEventListener(events_1.USER_STATE_CHANGED, listener);
        }
        User.removeEventListener = removeEventListener;
        /** Get the nullable OneSignal Id associated with the user. */
        function getOnesignalId() {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    if (!helpers_1.isNativeModuleLoaded(RNOneSignal)) {
                        return [2 /*return*/, Promise.reject(new Error('OneSignal native module not loaded'))];
                    }
                    return [2 /*return*/, RNOneSignal.getOnesignalId()];
                });
            });
        }
        User.getOnesignalId = getOnesignalId;
        /** Get the nullable External Id associated with the user. */
        function getExternalId() {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    if (!helpers_1.isNativeModuleLoaded(RNOneSignal)) {
                        return [2 /*return*/, Promise.reject(new Error('OneSignal native module not loaded'))];
                    }
                    return [2 /*return*/, RNOneSignal.getExternalId()];
                });
            });
        }
        User.getExternalId = getExternalId;
        /** Explicitly set a 2-character language code for the user. */
        function setLanguage(language) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.setLanguage(language);
        }
        User.setLanguage = setLanguage;
        /** Set an alias for the current user. If this alias label already exists on this user, it will be overwritten with the new alias id. */
        function addAlias(label, id) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.addAlias(label, id);
        }
        User.addAlias = addAlias;
        /** Set aliases for the current user. If any alias already exists, it will be overwritten to the new values. */
        function addAliases(aliases) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.addAliases(aliases);
        }
        User.addAliases = addAliases;
        /** Remove an alias from the current user. */
        function removeAlias(label) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.removeAlias(label);
        }
        User.removeAlias = removeAlias;
        /** Remove aliases from the current user. */
        function removeAliases(labels) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.removeAliases(labels);
        }
        User.removeAliases = removeAliases;
        /** Add a new email subscription to the current user. */
        function addEmail(email) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.addEmail(email);
        }
        User.addEmail = addEmail;
        /**
         * Remove an email subscription from the current user. Returns false if the specified email does not exist on the user within the SDK,
         * and no request will be made.
         */
        function removeEmail(email) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.removeEmail(email);
        }
        User.removeEmail = removeEmail;
        /** Add a new SMS subscription to the current user. */
        function addSms(smsNumber) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.addSms(smsNumber);
        }
        User.addSms = addSms;
        /**
         * Remove an SMS subscription from the current user. Returns false if the specified SMS number does not exist on the user within the SDK,
         * and no request will be made.
         */
        function removeSms(smsNumber) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.removeSms(smsNumber);
        }
        User.removeSms = removeSms;
        /**
         * Add a tag for the current user. Tags are key:value pairs used as building blocks for targeting specific users and/or personalizing
         * messages. If the tag key already exists, it will be replaced with the value provided here.
         */
        function addTag(key, value) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            if (!key || value === undefined || value === null) {
                console.error('OneSignal: addTag: must include a key and a value');
                return;
            }
            // forces values to be string types
            if (typeof value !== 'string') {
                console.warn('OneSignal: addTag: tag value must be of type string; attempting to convert');
                value = String(value);
            }
            RNOneSignal.addTag(key, value);
        }
        User.addTag = addTag;
        /**
         * Add multiple tags for the current user. Tags are key:value pairs used as building blocks for targeting
         * specific users and/or personalizing messages. If the tag key already exists, it will be replaced with
         * the value provided here.
         */
        function addTags(tags) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            if (!tags || Object.keys(tags).length === 0) {
                console.error('OneSignal: addTags: argument must be of type object of the form { key : "value" }');
                return;
            }
            var convertedTags = tags;
            Object.keys(tags).forEach(function (key) {
                if (typeof convertedTags[key] !== 'string') {
                    console.warn('OneSignal: addTags: tag value for key ' +
                        key +
                        ' must be of type string; attempting to convert');
                    convertedTags[key] = String(convertedTags[key]);
                }
            });
            RNOneSignal.addTags(tags);
        }
        User.addTags = addTags;
        /** Remove the data tag with the provided key from the current user. */
        function removeTag(key) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            if (typeof key !== 'string') {
                console.error('OneSignal: removeTag: key argument must be of type string');
                return;
            }
            RNOneSignal.removeTags([key]);
        }
        User.removeTag = removeTag;
        /** Remove multiple tags with the provided keys from the current user. */
        function removeTags(keys) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            if (!Array.isArray(keys)) {
                console.error('OneSignal: removeTags: argument must be of array type');
                return;
            }
            RNOneSignal.removeTags(keys);
        }
        User.removeTags = removeTags;
        /** Returns the local tags for the current user. */
        function getTags() {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal)) {
                return Promise.reject(new Error('OneSignal native module not loaded'));
            }
            return RNOneSignal.getTags();
        }
        User.getTags = getTags;
    })(User = OneSignal.User || (OneSignal.User = {}));
    var Notifications;
    (function (Notifications) {
        /**
         * @deprecated This method is deprecated. It has been replaced by {@link getPermissionAsync}.
         */
        function hasPermission() {
            console.warn('OneSignal: This method has been deprecated. Use getPermissionAsync instead for getting notification permission status.');
            return notificationPermission;
        }
        Notifications.hasPermission = hasPermission;
        /**
         * Whether this app has push notification permission. Returns true if the user has accepted permissions,
         * or if the app has ephemeral or provisional permission.
         */
        function getPermissionAsync() {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, RNOneSignal.hasNotificationPermission()];
                });
            });
        }
        Notifications.getPermissionAsync = getPermissionAsync;
        /**
         * Prompt the user for permission to receive push notifications. This will display the native system prompt to request push
         * notification permission. Use the fallbackToSettings parameter to prompt to open the settings app if a user has already
         * declined push permissions.
         */
        function requestPermission(fallbackToSettings) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal)) {
                return Promise.reject(new Error('OneSignal native module not loaded'));
            }
            return RNOneSignal.requestNotificationPermission(fallbackToSettings);
        }
        Notifications.requestPermission = requestPermission;
        /**
         * Whether attempting to request notification permission will show a prompt. Returns true if the device has not been prompted for push
         * notification permission already.
         */
        function canRequestPermission() {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal)) {
                return Promise.reject(new Error('OneSignal native module not loaded'));
            }
            return RNOneSignal.canRequestNotificationPermission();
        }
        Notifications.canRequestPermission = canRequestPermission;
        /**
         * Instead of having to prompt the user for permission to send them push notifications, your app can request provisional authorization.
         * For more information: https://documentation.onesignal.com/docs/ios-customizations#provisional-push-notifications
         * @param  {(response:{accepted:boolean})=>void} handler
         */
        function registerForProvisionalAuthorization(handler) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            if (react_native_1.Platform.OS === 'ios') {
                helpers_1.isValidCallback(handler);
                RNOneSignal.registerForProvisionalAuthorization(handler);
            }
            else {
                console.log('registerForProvisionalAuthorization: this function is not supported on Android');
            }
        }
        Notifications.registerForProvisionalAuthorization = registerForProvisionalAuthorization;
        /** iOS Only.
         * Returns the enum for the native permission of the device. It will be one of:
         * OSNotificationPermissionNotDetermined,
         * OSNotificationPermissionDenied,
         * OSNotificationPermissionAuthorized,
         * OSNotificationPermissionProvisional - only available in iOS 12,
         * OSNotificationPermissionEphemeral - only available in iOS 14
         * */
        function permissionNative() {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal)) {
                return Promise.reject(new Error('OneSignal native module not loaded'));
            }
            return RNOneSignal.permissionNative();
        }
        Notifications.permissionNative = permissionNative;
        /**
         * Add listeners for notification click and/or lifecycle events. */
        function addEventListener(event, listener) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            helpers_1.isValidCallback(listener);
            if (event === 'click') {
                RNOneSignal.addNotificationClickListener();
                eventManager.addEventListener(events_1.NOTIFICATION_CLICKED, listener);
            }
            else if (event === 'foregroundWillDisplay') {
                RNOneSignal.addNotificationForegroundLifecycleListener();
                eventManager.addEventListener(events_1.NOTIFICATION_WILL_DISPLAY, listener);
            }
            else if (event === 'permissionChange') {
                helpers_1.isValidCallback(listener);
                RNOneSignal.addPermissionObserver();
                eventManager.addEventListener(events_1.PERMISSION_CHANGED, listener);
            }
        }
        Notifications.addEventListener = addEventListener;
        /**
         * Remove listeners for notification click and/or lifecycle events. */
        function removeEventListener(event, listener) {
            if (event === 'click') {
                eventManager.removeEventListener(events_1.NOTIFICATION_CLICKED, listener);
            }
            else if (event === 'foregroundWillDisplay') {
                eventManager.removeEventListener(events_1.NOTIFICATION_WILL_DISPLAY, listener);
            }
            else if (event === 'permissionChange') {
                eventManager.removeEventListener(events_1.PERMISSION_CHANGED, listener);
            }
            else {
                return;
            }
        }
        Notifications.removeEventListener = removeEventListener;
        /**
         * Removes all OneSignal notifications.
         */
        function clearAll() {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.clearAllNotifications();
        }
        Notifications.clearAll = clearAll;
        /**
         * Android Only.
         * Removes a single OneSignal notification based on its Android notification integer id.
         */
        function removeNotification(id) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            if (react_native_1.Platform.OS === 'android') {
                RNOneSignal.removeNotification(id);
            }
            else {
                console.log('removeNotification: this function is not supported on iOS');
            }
        }
        Notifications.removeNotification = removeNotification;
        /**
         * Android Only.
         * Removes all OneSignal notifications based on its Android notification group Id.
         * @param {string} id - notification group id to cancel
         */
        function removeGroupedNotifications(id) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            if (react_native_1.Platform.OS === 'android') {
                RNOneSignal.removeGroupedNotifications(id);
            }
            else {
                console.log('removeGroupedNotifications: this function is not supported on iOS');
            }
        }
        Notifications.removeGroupedNotifications = removeGroupedNotifications;
    })(Notifications = OneSignal.Notifications || (OneSignal.Notifications = {}));
    var InAppMessages;
    (function (InAppMessages) {
        /**
         * Add listeners for In-App Message click and/or lifecycle events.
         */
        function addEventListener(event, listener) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal)) {
                return;
            }
            if (event === 'click') {
                helpers_1.isValidCallback(listener);
                RNOneSignal.addInAppMessageClickListener();
                eventManager.addEventListener(events_1.IN_APP_MESSAGE_CLICKED, listener);
            }
            else {
                if (event === 'willDisplay') {
                    helpers_1.isValidCallback(listener);
                    eventManager.addEventListener(events_1.IN_APP_MESSAGE_WILL_DISPLAY, listener);
                }
                else if (event === 'didDisplay') {
                    helpers_1.isValidCallback(listener);
                    eventManager.addEventListener(events_1.IN_APP_MESSAGE_DID_DISPLAY, listener);
                }
                else if (event === 'willDismiss') {
                    helpers_1.isValidCallback(listener);
                    eventManager.addEventListener(events_1.IN_APP_MESSAGE_WILL_DISMISS, listener);
                }
                else if (event === 'didDismiss') {
                    helpers_1.isValidCallback(listener);
                    eventManager.addEventListener(events_1.IN_APP_MESSAGE_DID_DISMISS, listener);
                }
                else {
                    return;
                }
                RNOneSignal.addInAppMessagesLifecycleListener();
            }
        }
        InAppMessages.addEventListener = addEventListener;
        /**
         * Remove listeners for In-App Message click and/or lifecycle events.
         */
        function removeEventListener(event, listener) {
            if (event === 'click') {
                eventManager.removeEventListener(events_1.IN_APP_MESSAGE_CLICKED, listener);
            }
            else {
                if (event === 'willDisplay') {
                    eventManager.removeEventListener(events_1.IN_APP_MESSAGE_WILL_DISPLAY, listener);
                }
                else if (event === 'didDisplay') {
                    eventManager.removeEventListener(events_1.IN_APP_MESSAGE_DID_DISPLAY, listener);
                }
                else if (event === 'willDismiss') {
                    eventManager.removeEventListener(events_1.IN_APP_MESSAGE_WILL_DISMISS, listener);
                }
                else if (event === 'didDismiss') {
                    eventManager.removeEventListener(events_1.IN_APP_MESSAGE_DID_DISMISS, listener);
                }
                else {
                    return;
                }
            }
        }
        InAppMessages.removeEventListener = removeEventListener;
        /**
         * Add a trigger for the current user. Triggers are currently explicitly used to determine whether a specific IAM should be
         * displayed to the user.
         */
        function addTrigger(key, value) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            // value can be assigned to `false` so we cannot just check `!value`
            if (!key || value == null) {
                console.error('OneSignal: addTrigger: must include a key and a value');
            }
            var trigger = {};
            trigger[key] = value;
            RNOneSignal.addTriggers(trigger);
        }
        InAppMessages.addTrigger = addTrigger;
        /**
         * Add multiple triggers for the current user. Triggers are currently explicitly used to determine whether a specific IAM should
         * be displayed to the user.
         */
        function addTriggers(triggers) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            var keys = Object.keys(triggers);
            if (keys.length === 0) {
                console.error("OneSignal: addTriggers: argument must be an object of the form { key : 'value' }");
            }
            RNOneSignal.addTriggers(triggers);
        }
        InAppMessages.addTriggers = addTriggers;
        /** Remove the trigger with the provided key from the current user. */
        function removeTrigger(key) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.removeTrigger(key);
        }
        InAppMessages.removeTrigger = removeTrigger;
        /** Remove multiple triggers from the current user. */
        function removeTriggers(keys) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.removeTriggers(keys);
        }
        InAppMessages.removeTriggers = removeTriggers;
        /** Clear all triggers from the current user. */
        function clearTriggers() {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.clearTriggers();
        }
        InAppMessages.clearTriggers = clearTriggers;
        /**
         * Set whether in-app messaging is currently paused.
         * When set to true no IAM will be presented to the user regardless of whether they qualify for them.
         * When set to 'false` any IAMs the user qualifies for will be presented to the user at the appropriate time.
         */
        function setPaused(pause) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.paused(pause);
        }
        InAppMessages.setPaused = setPaused;
        /** Whether in-app messaging is currently paused. */
        function getPaused() {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal)) {
                return Promise.reject(new Error('OneSignal native module not loaded'));
            }
            return RNOneSignal.getPaused();
        }
        InAppMessages.getPaused = getPaused;
    })(InAppMessages = OneSignal.InAppMessages || (OneSignal.InAppMessages = {}));
    var Location;
    (function (Location) {
        /** Prompts the user for location permissions to allow geotagging from the OneSignal dashboard. */
        function requestPermission() {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.requestLocationPermission();
        }
        Location.requestPermission = requestPermission;
        /** Disable or enable location collection (defaults to enabled if your app has location permission). */
        function setShared(shared) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.setLocationShared(shared);
        }
        Location.setShared = setShared;
        /**
         * Checks if location collection is enabled or disabled.
         * @param {(value: boolean) => void} handler
         */
        function isShared() {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal)) {
                return Promise.reject(new Error('OneSignal native module not loaded'));
            }
            return RNOneSignal.isLocationShared();
        }
        Location.isShared = isShared;
    })(Location = OneSignal.Location || (OneSignal.Location = {}));
    var Session;
    (function (Session) {
        /** Increases the "Count" of this Outcome by 1 and will be counted each time sent. */
        function addOutcome(name) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.addOutcome(name);
        }
        Session.addOutcome = addOutcome;
        /** Increases "Count" by 1 only once. This can only be attributed to a single notification. */
        function addUniqueOutcome(name) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.addUniqueOutcome(name);
        }
        Session.addUniqueOutcome = addUniqueOutcome;
        /**
         * Increases the "Count" of this Outcome by 1 and the "Sum" by the value. Will be counted each time sent.
         * If the method is called outside of an attribution window, it will be unattributed until a new session occurs.
         */
        function addOutcomeWithValue(name, value) {
            if (!helpers_1.isNativeModuleLoaded(RNOneSignal))
                return;
            RNOneSignal.addOutcomeWithValue(name, Number(value));
        }
        Session.addOutcomeWithValue = addOutcomeWithValue;
    })(Session = OneSignal.Session || (OneSignal.Session = {}));
})(OneSignal = exports.OneSignal || (exports.OneSignal = {}));
var OSNotification_1 = require("./OSNotification");
Object.defineProperty(exports, "OSNotification", { enumerable: true, get: function () { return OSNotification_1.default; } });
